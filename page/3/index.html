<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"wangweiye01.github.io","root":"/blog/","images":"/blog/images","scheme":"Muse","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/blog/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Coding &amp; Life">
<meta property="og:url" content="https://wangweiye01.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="Coding &amp; Life">
<meta property="og:locale">
<meta property="article:author" content="老枪">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://wangweiye01.github.io/blog/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Coding & Life</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Coding & Life</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">求知若饥，虚心若愚</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">老枪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/13/security20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/13/security20/" class="post-title-link" itemprop="url">Spring Security20 - 如何实现不同的接口不同的安全策略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-13 09:01:18" itemprop="dateCreated datePublished" datetime="2021-07-13T09:01:18+08:00">2021-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近有开发小伙伴提了一个有趣的问题。他正在做一个项目，涉及两种风格，一种是给小程序出接口，安全上使用无状态的<strong>JWT Token</strong>;另一种是管理后台使用的是<strong>Freemarker</strong>，也就是前后端不分离的<strong>Session</strong>机制。用<strong>Spring Security</strong>该怎么办？</p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>我们可以通过多次继承<a target="_blank" rel="noopener" href="https://www.wangweiye.cc/blog/2021/07/03/security5/">WebSecurityConfigurerAdapter</a>构建多个<code>HttpSecurity</code>。<code>HttpSecurity</code> 对象会告诉我们如何验证用户的身份，如何进行访问控制，采取的何种策略等等。</p>
<p>如果你看过之前的教程，我们是这么配置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单策略配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> felord.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 14 :58 2019/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSpringBootWebSecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type Default configurer adapter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 配置 httpSecurity</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置了一个<code>HttpSecurity</code>，我们如法炮制再增加一个<code>WebSecurityConfigurerAdapter</code>的子类来配置另一个<code>HttpSecurity</code>。伴随而来的还有不少的问题要解决。</p>
<h3 id="2-1-如何路由不同的安全配置"><a href="#2-1-如何路由不同的安全配置" class="headerlink" title="2.1 如何路由不同的安全配置"></a>2.1 如何路由不同的安全配置</h3><p>我们配置了两个<code>HttpSecurity</code>之后，程序如何让小程序接口和后台接口走对应的<code>HttpSecurity</code>?</p>
<p><code>HttpSecurity.antMatcher(String antPattern)</code>可以提供过滤机制。比如我们配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 配置 httpSecurity</span></span><br><span class="line">    http.antMatcher(<span class="string">&quot;/admin/v1&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么该<code>HttpSecurity</code>将只提供给以<code>/admin/v1</code>开头的所有<strong>URL</strong>。这要求我们针对不同的客户端指定统一的<strong>URL</strong>前缀。</p>
<blockquote>
<p>举一反三只要<code>HttpSecurity</code>提供的功能都可以进行个性化定制。比如登录方式，角色体系等。</p>
</blockquote>
<h3 id="2-2-如何指定默认的HttpSecurity"><a href="#2-2-如何指定默认的HttpSecurity" class="headerlink" title="2.2 如何指定默认的HttpSecurity"></a>2.2 如何指定默认的HttpSecurity</h3><p>我们可以通过在<code>WebSecurityConfigurerAdapter</code>实现上使用<code>@Order</code>注解来指定优先级，数值越大优先级越低，没有<code>@Order</code>注解将优先级最低。</p>
<h3 id="2-3-如何配置不同的UserDetailsService"><a href="#2-3-如何配置不同的UserDetailsService" class="headerlink" title="2.3 如何配置不同的UserDetailsService"></a>2.3 如何配置不同的UserDetailsService</h3><p>很多情况下我们希望普通用户和管理用户完全隔离，我们就需要多个<code>UserDetailsService</code>，你可以在下面的方法中对<code>AuthenticationManagerBuilder</code>进行具体的设置来配置<code>UserDetailsService</code>，同时也可以配置不同的密码策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">DaoAuthenticationProvider</span> <span class="variable">daoAuthenticationProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">    daoAuthenticationProvider.setUserDetailsService(<span class="keyword">new</span> <span class="title class_">UserDetailsService</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">            <span class="comment">// 自行实现</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 也可以设计特定的密码策略</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    daoAuthenticationProvider.setPasswordEncoder(bCryptPasswordEncoder);</span><br><span class="line">    auth.authenticationProvider(daoAuthenticationProvider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-最终的配置模板"><a href="#2-4-最终的配置模板" class="headerlink" title="2.4 最终的配置模板"></a>2.4 最终的配置模板</h3><p>上面的几个问题解决之后，我们基本上掌握了在一个应用中执行多种安全策略。配置模板如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个策略配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> felord.cn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 14 :58 2019/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = true, securedEnabled = true)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSpringBootWebSecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后台接口安全策略. 默认配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AdminConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">DaoAuthenticationProvider</span> <span class="variable">daoAuthenticationProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">            <span class="comment">//用户详情服务个性化</span></span><br><span class="line">            daoAuthenticationProvider.setUserDetailsService(<span class="keyword">new</span> <span class="title class_">UserDetailsService</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 自行实现</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 也可以设计特定的密码策略</span></span><br><span class="line">            <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">            daoAuthenticationProvider.setPasswordEncoder(bCryptPasswordEncoder);</span><br><span class="line">            auth.authenticationProvider(daoAuthenticationProvider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 根据需求自行定制</span></span><br><span class="line">            http.antMatcher(<span class="string">&quot;/admin/v1&quot;</span>)</span><br><span class="line">                    .sessionManagement(Customizer.withDefaults())</span><br><span class="line">                    .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * app接口安全策略. 没有&#123;<span class="doctag">@link</span> Order&#125;注解优先级比上面低</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">DaoAuthenticationProvider</span> <span class="variable">daoAuthenticationProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">            <span class="comment">//用户详情服务个性化</span></span><br><span class="line">            daoAuthenticationProvider.setUserDetailsService(<span class="keyword">new</span> <span class="title class_">UserDetailsService</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 自行实现</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 也可以设计特定的密码策略</span></span><br><span class="line">            <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">            daoAuthenticationProvider.setPasswordEncoder(bCryptPasswordEncoder);</span><br><span class="line">            auth.authenticationProvider(daoAuthenticationProvider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 根据需求自行定制</span></span><br><span class="line">            http.antMatcher(<span class="string">&quot;/app/v1&quot;</span>)</span><br><span class="line">                    .sessionManagement(Customizer.withDefaults())</span><br><span class="line">                    .formLogin(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>今天我们解决了如何针对不同类型接口采取不同的安全策略的方法，希望对你有用</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-muti-httpsecurity.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/13/security19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/13/security19/" class="post-title-link" itemprop="url">Spring Security19 - 过滤器链的机制和特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-13 08:37:50" itemprop="dateCreated datePublished" datetime="2021-07-13T08:37:50+08:00">2021-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>过滤器作为 <strong>Spring Security</strong> 的重中之重，我们需要了解其中的机制。这样我们才能根据业务需求的变化进行定制。今天来探讨一下 <strong>Spring Security</strong> 中的过滤器链机制</p>
<h2 id="2-Spring-Security-过滤器链"><a href="#2-Spring-Security-过滤器链" class="headerlink" title="2. Spring Security 过滤器链"></a>2. Spring Security 过滤器链</h2><p>客户端（APP 和后台管理客户端）向应用程序发送请求，然后应用根据请求的 <strong>URI</strong> 的路径来确定该请求的过滤器链（<strong>Filter</strong>）以及最终的具体 <strong>Servlet</strong> 控制器（<strong>Controller</strong>）。</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/20200309171604-20210713.jpeg"></p>
<p>从上图我们可以看出 <strong>Spring Security</strong> 以一个单 <strong>Filter（FilterChainProxy）</strong> 存在于整个过滤器链中，而这个 <code>FilterChainProxy</code> 实际内部代理着众多的 <strong>Spring Security Filter</strong> 。这简直就是套娃啊！</p>
<h3 id="2-1-过滤器链的形成过程"><a href="#2-1-过滤器链的形成过程" class="headerlink" title="2.1 过滤器链的形成过程"></a>2.1 过滤器链的形成过程</h3><p>再多说一点 <strong>Filter</strong> 们的初始化过程，首先 <strong>Filter</strong> 们按照一定的顺序被 <code>SecurityBuilder</code> 的实现来组装为 <code>SecurityFilterChain</code> ，然后通过 <code>WebSecurity</code> 注入到 <code>FilterChainProxy</code> 中去，接着 <code>FilterChainProxy</code> 又在 <code>WebSecurityConfiguration</code> 中以 <code>springSecurityFilterChain</code> 的名称注册为 <strong>Spring Bean</strong> 。实际上还有一个隐藏层 <code>DelegatingFilterProxy</code> 代理了 <code>springSecurityFilterChain</code> 注入到最后整个 <strong>Servlet</strong> 过滤器链中。 简单画了个图：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/20200309234424-20210713.png"></p>
<blockquote>
<p>事实上 <strong>Spring Security</strong> 的内置 <strong>Filter</strong> 对于 <strong>Spring IoC</strong> 容器来说都是不可见的。</p>
</blockquote>
<p><strong>Spring Security</strong> 允许有多 条过滤器链并行，<strong>Spring Security</strong> 的 <code>FilterChainProxy</code> 可以代理多条过滤器链并根据不同的 <strong>URI</strong> 匹配策略进行分发。但是每个请求每次只能被分发到一条过滤器链。如下图所示：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/20200309170054-20210713.png"></p>
<blockquote>
<p>实际每条过滤链 就是一个 <code>SecurityFilterChain</code></p>
</blockquote>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>今天我们通过对 <strong>Spring Security</strong> 中 过滤器链机制，对于深入学习 <strong>Spring Security</strong> 有着至关重要的意义。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-filter-chain.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security18/" class="post-title-link" itemprop="url">Spring Security18 - 动态权限控制（下）实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 15:38:01" itemprop="dateCreated datePublished" datetime="2021-07-12T15:38:01+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>中提到的第 32 个 <code>Filter</code> 不知道你是否有印象。它决定了访问特定路径应该具备的权限，访问的用户的角色，权限是什么？访问的路径需要什么样的角色和权限？ 它就是 <code>FilterSecurityInterceptor</code> ，正是我们需要的那个轮子。</p>
<h2 id="2-FilterSecurityInterceptor"><a href="#2-FilterSecurityInterceptor" class="headerlink" title="2. FilterSecurityInterceptor"></a>2. FilterSecurityInterceptor</h2><p>过滤器排行榜第 32 位！肩负对接口权限认证的重要职责。我们来看它的过滤逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">FilterInvocation</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">    invoke(fi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化了一个 <code>FilterInvocation</code> 然后被 <code>invoke</code> 方法处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> ((fi.getRequest() != <span class="literal">null</span>)</span><br><span class="line">            &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="literal">null</span>)</span><br><span class="line">            &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">        <span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line">        <span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">        fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">        <span class="keyword">if</span> (fi.getRequest() != <span class="literal">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">            fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次请求被 <code>Filter</code> 过滤都会被打上标记 <code>FILTER_APPLIED</code>，没有被打上标记的 走了父类的 <code>beforeInvocation</code> 方法然后再进入过滤器链，看上去是走了一个前置的处理。那么前置处理了什么呢?</p>
<p>首先会通过 <code>this.obtainSecurityMetadataSource().getAttributes(Object object)</code> 拿受保护对象（就是当前请求的URI）所有的映射角色（<code>ConfigAttribute</code> 直接理解为角色的进一步抽象） 。然后使用访问决策管理器 <code>AccessDecisionManager</code> 进行投票决策来确定是否放行。 我们来看一下这两个接口。</p>
<p>安全拦截器和“安全对象”模型参考：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/b88f6253bbacd315-20210712.jpeg"></p>
<h2 id="3-FilterInvocationSecurityMetadataSource"><a href="#3-FilterInvocationSecurityMetadataSource" class="headerlink" title="3. FilterInvocationSecurityMetadataSource"></a>3. FilterInvocationSecurityMetadataSource</h2><p>这个接口是 <code>FilterSecurityInterceptor</code> 的属性，UML图如下：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/68cf4326ed3de0a3-20210712.png"></p>
<p><code>FilterInvocationSecurityMetadataSource</code> 是一个标记接口，其抽象方法继承自 <code>SecurityMetadataSource</code>和<code>AopInfrastructureBean</code> 。它的作用是来获取我们上一篇文章所描述的<strong>资源角色元数据。</strong></p>
<ul>
<li><strong>Collection getAttributes(Object object)</strong> 根据提供的受保护对象的信息，其实就是URI，获取该URI 配置的所有角色</li>
<li><strong>Collection getAllConfigAttributes()</strong> 这个就是获取全部角色</li>
<li><strong>boolean supports(Class&lt;?&gt; clazz)</strong> 对特定的安全对象是否提供 <code>ConfigAttribute</code> 支持</li>
</ul>
<h3 id="3-1-自定义实现-FilterInvocationSecurityMetadataSource-的思路分析"><a href="#3-1-自定义实现-FilterInvocationSecurityMetadataSource-的思路分析" class="headerlink" title="3.1 自定义实现 FilterInvocationSecurityMetadataSource 的思路分析"></a>3.1 自定义实现 FilterInvocationSecurityMetadataSource 的思路分析</h3><p><strong>所有的思路仅供参考，实际以你的业务为准！</strong></p>
<p><code>Collection&lt;ConfigAttribute&gt; getAttributes(Object object)</code> 方法的实现：肯定是获取请求中的 <code>URI</code> 来和 所有的 资源配置中的 <code>Ant Pattern</code> 进行匹配以获取对应的资源配置, 这里需要将资源查询接口查询的资源配置封装为 <code>AntPathRequestMatcher</code>以方便进行 <code>Ant Match</code> 。</p>
<p>这里需要特别提一下如果你使用 <strong>Restful</strong> 风格，这里 <strong>增删改查</strong> 将非常方便你来对资源的管控。参考的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestMatcherCreator <span class="title function_">requestMatcherCreator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> metaResources -&gt; metaResources.stream()</span><br><span class="line">        .map(metaResource -&gt; <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(metaResource.getPattern(), metaResource.getMethod()))</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HttpRequest</code> 匹配到对应的资源配置后就能根据资源配置去取对应的角色集合。这些角色将交给访问决策管理器 <code>AccessDecisionManager</code> 进行投票表决以决定是否放行。</p>
<h2 id="4-AccessDecisionManager"><a href="#4-AccessDecisionManager" class="headerlink" title="4. AccessDecisionManager"></a>4. AccessDecisionManager</h2><p>决策管理器，用来投票决定是否放行请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccessDecisionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 决策 主要通过其持有的 AccessDecisionVoter 来进行投票决策</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">            Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException,</span><br><span class="line">            InsufficientAuthenticationException;</span><br><span class="line">    <span class="comment">// 以确定AccessDecisionManager是否可以处理传递的ConfigAttribute</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute attribute)</span>;</span><br><span class="line">    <span class="comment">//以确保配置的AccessDecisionManager支持安全拦截器将呈现的安全 object 类型。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AccessDecisionManager</code> 有三个默认实现：</p>
<ul>
<li><strong>AffirmativeBased</strong> 基于肯定的决策器。 用户持有一个同意访问的角色就能通过。</li>
<li><strong>ConsensusBased</strong> 基于共识的决策器。 用户持有同意的角色数量多于禁止的角色数。</li>
<li><strong>UnanimousBased</strong> 基于一致的决策器。 用户持有的所有角色都同意访问才能放行。</li>
</ul>
<p>投票决策模型参考：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/e742dbb588cdbe41-20210712.jpeg"></p>
<h3 id="4-1-自定义-AccessDecisionManager"><a href="#4-1-自定义-AccessDecisionManager" class="headerlink" title="4.1 自定义 AccessDecisionManager"></a>4.1 自定义 AccessDecisionManager</h3><p>动态控制权限就需要我们实现自己的访问决策器。我们上面说了默认有三个实现，这里我选择基于肯定的决策器 <code>AffirmativeBased</code>，只要用户持有一个持有一个角色包含想要访问的资源就能访问该资源。接下来就是投票器 <code>AccessDecisionVoter</code> 的定义了，其实我们可以选择内置的</p>
<h2 id="5-AccessDecisionVoter"><a href="#5-AccessDecisionVoter" class="headerlink" title="5. AccessDecisionVoter"></a>5. AccessDecisionVoter</h2><p><code>AccessDecisionVoter</code> 将安全配置属性 <code>ConfigAttribute</code> 以特定的逻辑进行解析并基于特定的策略来进行投票，投赞成票时总票数 <code>+1</code> ，反对票总票数 <code>-1</code> ，弃权时总票数 <code>+0</code> , 然后由 <code>AccessDecisionManager</code> 根据具体的计票策略来决定是否放行。</p>
<h3 id="5-1-角色投票器-RoleVoter"><a href="#5-1-角色投票器-RoleVoter" class="headerlink" title="5.1 角色投票器 RoleVoter"></a>5.1 角色投票器 RoleVoter</h3><p><strong>Spring Security</strong> 提供的最常用的投票器是角色投票器 <code>RoleVoter</code>，它将安全配置属性 <code>ConfigAttribute</code> 视为简单的角色名称，并在用户被分配了该角色时授予访问权限。<br>如果任何 <code>ConfigAttribute</code> 以前缀 <code>ROLE_</code> 开头，它将投票。如果有一个 <code>GrantedAuthority</code> 返回一个字符串(通过 <code>getAuthority()</code> 方法)正好等于一个或多个从前缀 <code>ROLE_</code> 开始的 <code>ConfigAttributes</code>，它将投票授予访问权限。如果没有任何以 <code>ROLE_</code>开头的 <code>ConfigAttributes</code>匹配，则 <code>RoleVoter</code> 将投票拒绝访问。如果没有 <code>ConfigAttribute</code> 以<code>ROLE_</code>为前缀，将弃权。</p>
<p>这正是我们想要的投票器。</p>
<h3 id="5-2-角色分层投票器-RoleHierarchyVoter"><a href="#5-2-角色分层投票器-RoleHierarchyVoter" class="headerlink" title="5.2 角色分层投票器 RoleHierarchyVoter"></a>5.2 角色分层投票器 RoleHierarchyVoter</h3><p>通常要求应用程序中的特定角色应自动“包含”其他角色。例如，在具有 <code>ROLE_ADMIN</code> 和 <code>ROLE_USER</code> 角色概念的应用中，您可能希望管理员能够执行普通用户可以执行的所有操作。你不得不进行各种复杂的逻辑嵌套来满足这一需求。现在幸好有了 <code>RoleHierarchyVoter</code> 可以帮你减少这种负担。</p>
<p>它由上面的 <code>RoleVoter</code> 派生,通过配置了一个 <code>RoleHierarchy</code>就可以实现 <code>ROLE_ADMIN ⇒ ROLE_STAFF ⇒ ROLE_USER ⇒ ROLE_GUEST</code> 这种层次包含结构，<strong>左边的一定能访问右边可以访问的资源</strong>。具体的配置规则为：角色从左到右、从高到低以 <code>&gt;</code> 相连（注意两个空格），以换行符 <code>\n</code> 为分割线。举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROLE_ADMIN &gt; ROLE_STAFF</span><br><span class="line">ROLE_STAFF &gt; ROLE_USER</span><br><span class="line">ROLE_USER &gt; ROLE_GUEST</span><br></pre></td></tr></table></figure>

<p>请注意动态配置中你需要自行实现角色分层的逻辑。DEMO 中并未对该风格进行实现。</p>
<h2 id="6-配置"><a href="#6-配置" class="headerlink" title="6. 配置"></a>6. 配置</h2><p>配置需要两个方面</p>
<h3 id="6-1-自定义组件的配置"><a href="#6-1-自定义组件的配置" class="headerlink" title="6.1 自定义组件的配置"></a>6.1 自定义组件的配置</h3><p>我们需要将元数据加载器 和 访问决策器注入 <strong>Spring IoC</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态权限组件配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Felordcn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAccessControlConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  RequestMatcher 生成器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RequestMatcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMatcherCreator <span class="title function_">requestMatcherCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaResources -&gt; metaResources.stream()</span><br><span class="line">                .map(metaResource -&gt; <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(metaResource.getPattern(), metaResource.getMethod()))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元数据加载器</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> dynamicFilterInvocationSecurityMetadataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterInvocationSecurityMetadataSource <span class="title function_">dynamicFilterInvocationSecurityMetadataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DynamicFilterInvocationSecurityMetadataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  角色投票器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> roleVoter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RoleVoter <span class="title function_">roleVoter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleVoter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  基于肯定的访问决策器</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> decisionVoters  AccessDecisionVoter类型的 Bean 会自动注入到 decisionVoters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> affirmativeBased</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccessDecisionManager <span class="title function_">affirmativeBased</span><span class="params">(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AffirmativeBased</span>(decisionVoters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring Security</strong> 的 <strong>Java Configuration</strong> 不会公开它配置的每个 <strong>object</strong> 的每个 <strong>property</strong>。这简化了大多数用户的配置。</p>
<p>虽然有充分的理由不直接公开每个 <strong>property</strong>，但用户可能仍需要像本文一样的取实现个性化需求。为了解决这个问题，<strong>Spring Security</strong> 引入了 <code>ObjectPostProcessor</code> 的概念，它可用于修改或替换 <strong>Java Configuration</strong> 创建的许多 <code>Object</code> 实例。 <code>FilterSecurityInterceptor</code> 的替换配置正是通过这种方式来进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSpringBootWebSecurityConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_PROCESSING_URL</span> <span class="operator">=</span> <span class="string">&quot;/process&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Json login post processor json login post processor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the json login post processor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JsonLoginPostProcessor <span class="title function_">jsonLoginPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonLoginPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pre login filter pre login filter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginPostProcessors the login post processors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the pre login filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PreLoginFilter <span class="title function_">preLoginFilter</span><span class="params">(Collection&lt;LoginPostProcessor&gt; loginPostProcessors)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PreLoginFilter</span>(LOGIN_PROCESSING_URL, loginPostProcessors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Jwt 认证过滤器.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtTokenGenerator jwt 工具类 负责 生成 验证 解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtTokenStorage   jwt 缓存存储接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the jwt authentication filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAuthenticationFilter <span class="title function_">jwtAuthenticationFilter</span><span class="params">(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(jwtTokenGenerator, jwtTokenStorage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type Default configurer adapter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> PreLoginFilter preLoginFilter;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> AccessDecisionManager accessDecisionManager;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(auth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.configure(web);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            http.csrf().disable()</span><br><span class="line">                    .cors()</span><br><span class="line">                    .and()</span><br><span class="line">                    <span class="comment">// session 生成策略用无状态策略</span></span><br><span class="line">                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                    .and()</span><br><span class="line">                    .exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">SimpleAccessDeniedHandler</span>()).authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">SimpleAuthenticationEntryPoint</span>())</span><br><span class="line">                    .and()</span><br><span class="line">                    <span class="comment">//   动态权限配置</span></span><br><span class="line">                    .authorizeRequests().anyRequest().authenticated().withObjectPostProcessor(filterSecurityInterceptorObjectPostProcessor())</span><br><span class="line">                    .and()</span><br><span class="line">                    .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                    <span class="comment">// jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">                    .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                    <span class="comment">// 登录  成功后返回jwt token  失败后返回 错误信息</span></span><br><span class="line">                    .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br><span class="line">                    .and().logout().addLogoutHandler(<span class="keyword">new</span> <span class="title class_">CustomLogoutHandler</span>()).logoutSuccessHandler(<span class="keyword">new</span> <span class="title class_">CustomLogoutSuccessHandler</span>());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义 FilterSecurityInterceptor  ObjectPostProcessor 以替换默认配置达到动态权限的目的</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> ObjectPostProcessor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt; <span class="title function_">filterSecurityInterceptorObjectPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O object)</span> &#123;</span><br><span class="line">                    object.setAccessDecisionManager(accessDecisionManager);</span><br><span class="line">                    object.setSecurityMetadataSource(filterInvocationSecurityMetadataSource);</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你编写一个 <code>Controller</code> 方法就将其在数据库注册为一个资源进行动态的访问控制了。<strong>无须注解或者更详细的 Java Config 配置。</strong></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>从最开始到现在一共10个 <strong>DEMO</strong> 。我们循序渐进地从如何学习 <strong>Spring Security</strong> 到目前实现了基于 <strong>RBAC</strong>、动态的权限资源访问控制。如果你能坚持到现在那么已经能满足了一些基本开发定制的需要。当然 Spring Security 还有很多局部的一些概念，我也会在以后抽时间进行讲解。</p>
<p>本节代码在<code>day10</code>分支</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-dynamic-rbac-b.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security17/" class="post-title-link" itemprop="url">Spring Security17 - 动态权限控制（上）思路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 15:20:26" itemprop="dateCreated datePublished" datetime="2021-07-12T15:20:26+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>截止目前已经对 <strong>基于配置</strong> 和 <strong>基于注解</strong> 的角色访问控制进行了讲解。对于一些小项目来说基本是够用的。然而如果希望运营管理人员能够动态的配置和分配权限，以上两种方式显然是满足不了需求的。接下来我们来一起探讨一下思路。</p>
<h2 id="2-动态的权限控制同样依赖-RBAC-模型"><a href="#2-动态的权限控制同样依赖-RBAC-模型" class="headerlink" title="2. 动态的权限控制同样依赖 RBAC 模型"></a>2. 动态的权限控制同样依赖 RBAC 模型</h2><p>我们依然应该在 <strong>RBAC</strong> 及其变种的基础上构建动态的权限控制系统。所有被访问的目标，无论是 API、静态资源都应该是关联了角色的东西统称为 <strong>资源（Resource）</strong>。我们需要建立起角色和资源之间的关系。</p>
<h3 id="2-1-资源映射到角色"><a href="#2-1-资源映射到角色" class="headerlink" title="2.1 资源映射到角色"></a>2.1 资源映射到角色</h3><p>下面是一个资源到角色的映射关系图：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/a214b2eeacf3c078-20210712.png"></p>
<p>模型大致如上所示，每一个资源对应一个可能无重复的角色集（<code>Set</code> 集合）；你可以注意到一个细节 <code>Role 1</code> 既指向 <code>Resource 1</code> 又指向 <code>Resource 2</code> 中，这是可以理解的，毕竟有可能对同一资源的访问权可能分散到多个角色中去；当然也可以互斥这取决于你的业务。</p>
<p>我们选择资源映射到角色是因为当请求时，资源是唯一的而角色可能是多个，如果进行反转的话解析的效率低一些。</p>
<h2 id="3-请求认证过程"><a href="#3-请求认证过程" class="headerlink" title="3. 请求认证过程"></a>3. 请求认证过程</h2><p>这里有很多搞法，但是总体的思路是我们的请求肯定是带下面两个东西（起码在走到进行访问决策这一步是必须有的）：</p>
<ul>
<li><p><strong>URI</strong> 访问资源必然要用 <strong>URI</strong> 来定位，我们同样通过 <strong>URI</strong> 来和资源接口进行匹配；<strong>最好是 Ant match</strong>，因为<code>/user/1</code> 和 <code>/user/2</code> 有可能访问的是同一个资源接口。如果你想避免这种情况，要么在开发规约中禁止这种风格，这样的好处是配置人员可以不必熟悉 <strong>Ant</strong> 风格；要么必须让配置人员掌握 <strong>Ant</strong> 风格。</p>
</li>
<li><p><strong>Principal</strong>,<strong>Spring Security</strong> 中为 <code>Authentication</code> （认证主体），之前讲过的一个比较绕的概念，Spring Security 中的用户身份有两种 一种是 <strong>认证用户</strong> 另一种是 <strong>匿名用户</strong> ，它们都包含角色。拿到角色到角色集进行匹配。</p>
</li>
</ul>
<p>然后我画了一个下面的图来更加清晰的展示一下流程：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/12042685123f0f9c-20210712.png"></p>
<h2 id="4-如何结合安全框架"><a href="#4-如何结合安全框架" class="headerlink" title="4. 如何结合安全框架"></a>4. 如何结合安全框架</h2><p>虽然本文是 <strong>Spring Security</strong> 系列的，但是我们如果使用其它安全框架或者自己研发安全框架都可以依据上面的思路。如果需要用编程语言总结一下就是我们需要两个接口来协同：</p>
<ul>
<li><strong>获取资源角色关系这些元数据的接口</strong> 这是我们动态权限控制的基石，只有将角色和资源的映射关系接口化才能动态的进行权限控制。 这里没有唯一标准，根据你的业务来设计。</li>
<li><strong>对Request进行解析并和提取的元数据进行匹配的接口</strong> 这是我们动态权限控制的最终逻辑实现。 这里的规则同样也没有唯一标准</li>
</ul>
<p>抓住了这两点之后我们就非常了然了，无非实现一个具有这两种功能的 <code>Filter</code> ，注入安全框架的过滤链中的合适位置中。要么你可以自己造个轮子，要么你使用现在有的轮子。那么有没有现成的轮子呢？ 我一般建议如果你在造轮子前先看看你选型的安全框架有没有现成的轮子可用。当现成有轮子可用并且能够满足你的需要时往往能够事半功倍。如果没有合适的就造一个！</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇主要理清一下动态权限所需要的一些要点，并对请求认证的过程进行了分析。最后对结合安全框架定制也提供了一些个人的见解。实现也写了大部分，之所以拆分成上下篇，因为理论和实现放在一篇的话实在有点篇幅过长，分成上篇理论、下篇实践更加合适。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-dynamic-rbac-a.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security16/" class="post-title-link" itemprop="url">Spring Security16 - SecurityContext相关的知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 15:00:03" itemprop="dateCreated datePublished" datetime="2021-07-12T15:00:03+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>今天我们来讲一下如何在接口访问中检索当前认证用户信息。<br>我们先讲一下具体的场景。通常我们在认证后访问需要认证的资源时需要获取当前认证用户的信息。比如 “查询我的个人信息”。如果你直接在接口访问时显式的传入你的 <strong>UserID</strong> 肯定是不合适的。因为你认证通过后访问资源，系统是知道你是谁的。而且显式的暴露用户的检索接口也不安全。所以我们需要一个业务中可以检索当前认证用户的工具。 接下来我们来看看 <strong>Spring Security</strong> 是如何解决这个痛点的。</p>
<h2 id="2-安全上下文-SecurityContext"><a href="#2-安全上下文-SecurityContext" class="headerlink" title="2. 安全上下文 SecurityContext"></a>2. 安全上下文 SecurityContext</h2><p>不知道你有没有留意<a target="_blank" rel="noopener" href="https://www.wangweiye.cc/blog/2021/07/08/security12/">Spring Security12 - 使用 JWT 认证访问接口</a>中是如何实现 <strong>JWT</strong> 认证拦截器 <code>JwtAuthenticationFilter</code> 。当服务端对 <strong>JWT Token</strong> 认证通过后，会将认证用户的信息封装到 <code>UsernamePasswordAuthenticationToken</code> 中 并使用工具类放入安全上下文 <code>SecurityContext</code> 中，当服务端响应用户后又使用同一个工具类将 <code>UsernamePasswordAuthenticationToken</code> 从 <code>SecurityContext</code> 中 <code>clear</code> 掉。</p>
<p>我们来简单了解 <code>SecurityContext</code> 具体是个什么东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.security.core.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContext</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthentication</span><span class="params">(Authentication var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上来看很简单就是一个 存储 <code>Authentication</code> 的容器。而 <code>Authentication</code> 是一个用户凭证接口用来作为用户认证的凭证使用，通常常用的实现有 <strong>认证用户</strong> <code>UsernamePasswordAuthenticationToken</code> 和 <strong>匿名用户</strong> <code>AnonymousAuthenticationToken</code>。其中 <code>UsernamePasswordAuthenticationToken</code> 包含了 <code>UserDetails</code> , <code>AnonymousAuthenticationToken</code> 只包含了一个字符串 <code>anonymousUser</code> 作为匿名用户的标识。我们通过 <code>SecurityContext</code> 获取上下文时需要来进行类型判断。接下来我们来聊聊操作 <code>SecurityContext</code> 的工具类。</p>
<h2 id="3-SecurityContextHolder"><a href="#3-SecurityContextHolder" class="headerlink" title="3. SecurityContextHolder"></a>3. SecurityContextHolder</h2><p>这个工具类就是 <code>SecurityContextHolder</code> 。 它提供了两个有用的方法：</p>
<ul>
<li><strong>setContext</strong> 设置当前的 <code>SecurityContext</code></li>
<li><strong>getContext</strong> 获取当前的 <code>SecurityContext</code> , 进而你可以获取到当前认证用户。</li>
<li><strong>clearContext</strong> 清除当前的 <code>SecurityContext</code></li>
</ul>
<p>平常我们通过这三个方法来操作安全上下文 <code>SecurityContext</code> 。你可以直接在代码中使用工具类 <code>SecurityContextHolder</code> 获取用户信息，像下面一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;anonymousUser&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="type">UserDetails</span> <span class="variable">principal</span> <span class="operator">=</span> (UserDetails) authentication.getPrincipal();</span><br><span class="line">   <span class="keyword">return</span> principal.getUsername();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>通过上面的自定义方法就可以解析到 <code>UserDetails</code> 的用户信息,你可以扩展 <code>UserDetails</code> 使得信息符合你的业务需要。上面方法中的判断是必须的，如果是匿名用户（<code>AnonymousAuthenticationToken</code>）返回的 <code>Principal</code> 类型是一个字符串 <code>anonymousUser</code>。</p>
<h3 id="3-1-扩展知识：SecurityContextHolder-存储策略"><a href="#3-1-扩展知识：SecurityContextHolder-存储策略" class="headerlink" title="3.1 扩展知识：SecurityContextHolder 存储策略"></a>3.1 扩展知识：SecurityContextHolder 存储策略</h3><p>这里也扩展一下知识面，简单讲一下 <code>SecurityContextHolder</code> 是如何存储 <code>SecurityContext</code> 的。<code>SecurityContextHolder</code> 默认有三种存储 <code>SecurityContext</code> 的策略：</p>
<ul>
<li><strong>MODE_THREADLOCAL</strong> 利用<code>ThreadLocal</code>机制来保存每个使用者的<code>SecurityContext</code>，<strong>缺省策略</strong>，平常我们使用这个就行了。</li>
<li><strong>MODE_INHERITABLETHREADLOCAL</strong>利用<code>InheritableThreadLocal</code>机制来保存每个使用者的<code>SecurityContext</code>。多用于多线程环境环境下。<br>– <strong>MODE_GLOBAL</strong> 静态机制，作用域为全局。目前不太常用。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>SecurityContext</code> 是 <strong>Spring Security</strong> 中的一个非常重要类，今天不但介绍 <code>SecurityContext</code> 是什么、有什么作用，也对以前讲过的一些知识进行回顾。也对如何使用 <code>SecurityContextHolder</code> 操作 <code>SecurityContext</code> 进行了讲解。最后也简单讲述了 <code>SecurityContextHolder</code> 三种存储 <code>SecurityContext</code> 的策略和使用场景 。希望对你学习 <strong>Spring Security</strong> 有帮助。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-securitycontext.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security15/" class="post-title-link" itemprop="url">Spring Security15 - 基于注解的接口角色访问控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 14:12:08" itemprop="dateCreated datePublished" datetime="2021-07-12T14:12:08+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在上一篇文章我们讲解了如何通过 <strong>javaConfig</strong> 的方式配置接口的角色访问控制。其实还有一种更加灵活的配置方式 <strong>基于注解</strong>。今天我们就来探讨一下。DEMO 获取方式在文末。</p>
<h2 id="2-Spring-Security方法安全"><a href="#2-Spring-Security方法安全" class="headerlink" title="2. Spring Security方法安全"></a>2. Spring Security方法安全</h2><p><strong>Spring Security</strong> 基于注解的安全认证是通过在相关的方法上进行安全注解标记来实现的。</p>
<h3 id="2-1-开启全局方法安全"><a href="#2-1-开启全局方法安全" class="headerlink" title="2.1 开启全局方法安全"></a>2.1 开启全局方法安全</h3><p>我们可以在任何 <code>@Configuration</code>实例上使用 <code>@EnableGlobalMethodSecurity</code> 注解来启用全局方法安全注解功能。该注解提供了三种不同的机制来实现同一种功能，所以我们单独开一章进行探讨。</p>
<h2 id="3-EnableGlobalMethodSecurity-注解"><a href="#3-EnableGlobalMethodSecurity-注解" class="headerlink" title="3. @EnableGlobalMethodSecurity 注解"></a>3. @EnableGlobalMethodSecurity 注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123; GlobalMethodSecuritySelector.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableGlobalMethodSecurity &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基于表达式进行方法访问控制</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">prePostEnabled</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基于 <span class="doctag">@Secured</span> 注解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">securedEnabled</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基于 JSR-250 注解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">jsr250Enabled</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableGlobalMethodSecurity</code> 源码中提供了 <code>prePostEnabled</code> 、<code>securedEnabled</code> 和 <code>jsr250Enabled</code> 三种方式。当你开启全局基于注解的方法安全功能时，也就是使用 <code>@EnableGlobalMethodSecurity</code> 注解时我们需要选择使用这三种的一种或者其中几种。我们接下来将分别介绍它们。</p>
<h2 id="4-使用-prePostEnabled"><a href="#4-使用-prePostEnabled" class="headerlink" title="4. 使用 prePostEnabled"></a>4. 使用 prePostEnabled</h2><p>如果你在 <code>@EnableGlobalMethodSecurity</code> 设置 <code>prePostEnabled</code> 为 <code>true</code> ，则开启了基于表达式的方法安全控制。通过表达式运算结果的布尔值来决定是否可以访问（<code>true</code> 开放， <code>false</code> 拒绝 ）。<br>有时您可能需要执行开启 <code>prePostEnabled</code> 复杂的操作。对于这些实例，您可以扩展 <code>GlobalMethodSecurityConfiguration</code>，确保子类上存在<code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code> 。例如，如果要提供自定义 <code>MethodSecurityExpressionHandler</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">GlobalMethodSecurityConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> MethodSecurityExpressionHandler <span class="title function_">createExpressionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... create and return custom MethodSecurityExpressionHandler ...</span></span><br><span class="line">        <span class="keyword">return</span> expressionHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例属于高级操作，一般没有必要。无论是否继承<code>GlobalMethodSecurityConfiguration</code> 都将会开启四个注解。 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code> 侧重于方法调用的控制；而 <code>@PreFilter</code> 和 <code>@PostFilter</code> 侧重于数据的控制。</p>
<h3 id="4-1-PreAuthorize"><a href="#4-1-PreAuthorize" class="headerlink" title="4.1 @PreAuthorize"></a>4.1 @PreAuthorize</h3><p>在标记的方法调用之前，通过表达式来计算是否可以授权访问。接下来我来总结以下常用的表达式。</p>
<ul>
<li>基于 <code>SecurityExpressionOperations</code> 接口的表达式，也就是我们在上一文的 <code>javaConfig</code> 配置。示例： <code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code> 必须拥有 <code>ROLE_ADMIN</code> 角色。</li>
<li>基于 <code>UserDetails</code> 的表达式，此表达式用以对当前用户的一些额外的限定操作。示例：<code>@PreAuthorize(&quot;principal.username.startsWith(&#39;Felordcn&#39;)&quot;)</code> 用户名开头为 <code>Felordcn</code> 的用户才能访问。</li>
<li>基于对入参的<code>SpEL</code>表达式处理。关于<code>SpEL</code>表达式可参考官方文档。或者通过关注公众号：Felordcn 来获取相关资料。 示例： <code>@PreAuthorize(&quot;#id.equals(principal.username)&quot;)</code> 入参 <code>id</code> 必须同当前的用户名相同。</li>
</ul>
<h3 id="4-2-PostAuthorize"><a href="#4-2-PostAuthorize" class="headerlink" title="4.2 @PostAuthorize"></a>4.2 @PostAuthorize</h3><p>在标记的方法调用之后，通过表达式来计算是否可以授权访问。该注解是针对 <code>@PreAuthorize</code> 。区别在于先执行方法。而后进行表达式判断。如果方法没有返回值实际上等于开放权限控制；如果有返回值实际的结果是用户操作成功但是得不到响应。</p>
<h3 id="4-3-PreFilter"><a href="#4-3-PreFilter" class="headerlink" title="4.3 @PreFilter"></a>4.3 @PreFilter</h3><p>基于方法入参相关的表达式，对入参进行过滤。分页慎用！<strong>该过程发生在接口接收参数之前</strong>。 入参必须为 <code>java.util.Collection</code> 且支持 <code>remove(Object)</code> 的参数。如果有多个集合需要通过 <code>filterTarget=&lt;参数名&gt;</code> 来指定过滤的集合。内置保留名称 <code>filterObject</code> 作为集合元素的操作名来进行评估过滤。</p>
<p>样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参为Collection&lt;String&gt; ids   测试数据 [&quot;Felordcn&quot;,&quot;felord&quot;,&quot;jetty&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤掉  felord jetty  为  Felordcn</span></span><br><span class="line"><span class="meta">@PreFilter(value = &quot;filterObject.startsWith(&#x27;F&#x27;)&quot;,filterTarget = &quot;ids&quot;)</span></span><br><span class="line"><span class="comment">// 如果 当前用户持有 ROLE_AD 角色  参数都符合  否则 过滤掉不是 f 开头的   </span></span><br><span class="line"><span class="comment">// DEMO 用户不持有 ROLE_AD 角色  故而 集合只剩下 felord</span></span><br><span class="line"><span class="meta">@PreFilter(&quot;hasRole(&#x27;AD&#x27;) or filterObject.startsWith(&#x27;f&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-PostFilter"><a href="#4-4-PostFilter" class="headerlink" title="4.4 @PostFilter"></a>4.4 @PostFilter</h3><p>和<code>@PreFilter</code>不同的是， 基于返回值相关的表达式，对返回值进行过滤。分页慎用！<strong>该过程发生接口进行数据返回之前。</strong> 相关测试与<code>@PreFilter</code>相似，参见文末提供的 DEMO。</p>
<h2 id="5-使用-securedEnabled"><a href="#5-使用-securedEnabled" class="headerlink" title="5. 使用 securedEnabled"></a>5. 使用 securedEnabled</h2><p>如果你在 <code>@EnableGlobalMethodSecurity</code> 设置 <code>securedEnabled</code> 为 <code>true</code> ，就开启了角色注解 <code>@Secured</code> ，该注解功能要简单的多，默认情况下只能基于角色（默认需要带前缀 <code>ROLE_</code>）集合来进行访问控制决策。</p>
<p>该注解的机制是只要其声明的角色集合（<code>value</code>）中包含当前用户持有的任一角色就可以访问。也就是 用户的角色集合和 <code>@Secured</code> 注解的角色集合要存在非空的交集。 不支持使用 <strong>SpEL</strong> 表达式进行决策。</p>
<h2 id="6-使用-jsr250Enabled"><a href="#6-使用-jsr250Enabled" class="headerlink" title="6. 使用 jsr250Enabled"></a>6. 使用 jsr250Enabled</h2><p>启用 <strong>JSR-250</strong> 安全控制注解，这属于 <strong>JavaEE</strong> 的安全规范（现为 <strong>jakarta</strong> 项目）。一共有五个安全注解。如果你在 <code>@EnableGlobalMethodSecurity</code> 设置 <code>jsr250Enabled</code> 为 <code>true</code> ，就开启了 <strong>JavaEE</strong> 安全注解中的以下三个：</p>
<ul>
<li>@DenyAll 拒绝所有的访问</li>
<li>@PermitAll 同意所有的访问</li>
<li>@RolesAllowed 用法和 <strong>5.</strong> 中的 @Secured 一样。</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>今天讲解了 <strong>Spring Security</strong> 另一种基于注解的静态配置。相比较基于 <code>javaConfig</code> 的方式要灵活一些、粒度更细、基于 <strong>SpEL</strong> 表达式可以实现更加强大的功能。但是这两种的方式还是基于编程的静态方式，具有一定的局限性。更加灵活的方式应该是动态来处理用户的角色和资源的映射关系，这是以后我们将要解决的问题。</p>
<p>本次代码在<code>day09</code>分支</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-annotation-rbac.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security14/" class="post-title-link" itemprop="url">Spring Security14 - 基于配置的接口角色访问控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 11:52:31" itemprop="dateCreated datePublished" datetime="2021-07-12T11:52:31+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>对于受限的访问资源，并不是对所有认证通过的用户开放的。比如 <strong>A</strong> 用户的角色是会计，那么他就可以访问财务相关的资源。<strong>B</strong> 用户是人事，那么他只能访问人事相关的资源。我们在上一文中也对基于角色的访问控制的相关概念进行了探讨。在实际开发中我们如何对资源进行角色粒度的管控呢？今天我来告诉你 <strong>Spring Security</strong> 是如何来解决这个问题的。</p>
<h2 id="2-将角色写入-UserDetails"><a href="#2-将角色写入-UserDetails" class="headerlink" title="2. 将角色写入 UserDetails"></a>2. 将角色写入 UserDetails</h2><p>我们使用 <code>UserDetailsService</code> 加载 <code>UserDetails</code> 时也会把用户的 <code>GrantedAuthority</code> 权限集写入其中。你可以将角色持久化并在这个点进行注入然后配置访问策略，后续的问题交给 <strong>Spring Security</strong> 。</p>
<h2 id="3-在-HttpSecurity-中进行配置角色访问控制"><a href="#3-在-HttpSecurity-中进行配置角色访问控制" class="headerlink" title="3. 在 HttpSecurity 中进行配置角色访问控制"></a>3. 在 HttpSecurity 中进行配置角色访问控制</h2><p>我们可以通过配置 <code>WebSecurityConfigurerAdapter</code> 中的 <code>HttpSecurity</code> 来控制接口的角色访问。</p>
<h3 id="3-1-通过判断用户是否持有角色来进行访问控制"><a href="#3-1-通过判断用户是否持有角色来进行访问控制" class="headerlink" title="3.1 通过判断用户是否持有角色来进行访问控制"></a>3.1 通过判断用户是否持有角色来进行访问控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(&quot;/foo/test&quot;).hasRole(&quot;ADMIN&quot;)</span><br></pre></td></tr></table></figure>

<p>表示持有 <code>ROLE_ADMIN</code> 角色的用户才能访问 <code>/foo/test</code> 接口。注意：<code>hasRole(String role)</code> 方法入参不能携带前缀 <code>ROLE_</code> 。我们来查看 <code>SecurityExpressionRoot</code> 中相关源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasRole</span><span class="params">(String role)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasAnyRole(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显 <code>hasRole</code> 方法源于 <code>hasAnyRole</code> (持有任何其中角色之一，就能满足访问条件，用于一个接口开放给多个角色访问时) :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasAnyRole</span><span class="params">(String... roles)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasAnyAuthorityName(defaultRolePrefix, roles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个接口开放给多个角色，比如 <code>/foo/test</code> 开放给了 <code>ROLE_APP</code> 和 <code>ROLE_ADMIN</code> 可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(&quot;/foo/test&quot;).hasAnyRole(&quot;APP&quot;,&quot;ADMIN&quot;)</span><br></pre></td></tr></table></figure>

<p><code>hasAnyRole</code> 方法最终的实现为 <code>hasAnyAuthorityName(String prefix, String... roles)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasAnyAuthorityName</span><span class="params">(String prefix, String... roles)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; roleSet = getAuthoritySet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String role : roles) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">defaultedRole</span> <span class="operator">=</span> getRoleWithDefaultPrefix(prefix, role);</span><br><span class="line">        <span class="keyword">if</span> (roleSet.contains(defaultedRole)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面才是根本的实现, 需要一个 <code>prefix</code> 和每一个 <code>role</code> 进行拼接，然后用户的角色集合 <code>roleSet</code> 中包含了就返回<code>true</code>放行，否则就 <code>false</code> 拒绝。默认的 <code>prefix</code> 为 <code>defaultRolePrefix= ROLE_</code>。</p>
<h3 id="3-2-通过判断用户的-GrantedAuthority-来进行访问控制"><a href="#3-2-通过判断用户的-GrantedAuthority-来进行访问控制" class="headerlink" title="3.2 通过判断用户的 GrantedAuthority 来进行访问控制"></a>3.2 通过判断用户的 GrantedAuthority 来进行访问控制</h3><p>我们也可以通过 <code>hasAuthority</code> 和 <code>hasAnyAuthority</code> 来判定。 其实底层实现和 <code>hasAnyRole</code> 方法一样，只不过 <code>prefix</code> 为 <code>null</code> 。也就是你写入的 <code>GrantedAuthority</code> 是什么样子的，这里传入参数的就是什么样子的，不再受 <code>ROLE_</code> 前缀的制约。</p>
<h2 id="4-匿名访问"><a href="#4-匿名访问" class="headerlink" title="4. 匿名访问"></a>4. 匿名访问</h2><p>匿名身份验证的用户和未经身份验证的用户之间没有真正的概念差异。<strong>Spring Security</strong> 的匿名身份验证只是为您提供了一种更方便的方式来配置访问控制属性。所有的匿名用户都持有角色 <code>ROLE_ANONYMOUS</code> 。所以你可以使用 <strong>2.1</strong> 和 <strong>2.2</strong> 章节的方法来配置匿名访问:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(&quot;/foo/test&quot;).hasAuthority(&quot;ROLE_ANONYMOUS&quot;)</span><br></pre></td></tr></table></figure>

<p>你也可以通过以下方式进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(&quot;/foo/test&quot;).anonymous()</span><br></pre></td></tr></table></figure>

<h2 id="5-开放请求"><a href="#5-开放请求" class="headerlink" title="5. 开放请求"></a>5. 开放请求</h2><p>开放请求可以这么配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpSecurity.authorizeRequests().antMatchers(&quot;/foo/test&quot;).permitAll()</span><br></pre></td></tr></table></figure>

<h2 id="6-permitAll-与-anonymous-的一些探讨"><a href="#6-permitAll-与-anonymous-的一些探讨" class="headerlink" title="6. permitAll 与 anonymous 的一些探讨"></a>6. permitAll 与 anonymous 的一些探讨</h2><p><strong>开放请求</strong> 其实通常情况下跟 <strong>匿名请求</strong> 有交叉。它们的主要区别在于： 当前的  <code>Authentication</code> 为 <code>null</code> 时 <code>permitAll</code> 是放行的，而 <code>anonymous</code> 需要 <code>Authentication</code> 为 <code>AnonymousAuthenticationToken</code> 。这里是比较难以理解的，下面是来自 Spring 文档中的一些信息：</p>
<blockquote>
<p>通常，采用“默认拒绝”的做法被认为是一种良好的安全做法，在该方法中，您明确指定允许的内容，并禁止其他所有内容。定义未经身份验证的用户可以访问的内容的情况与此类似，尤其是对于Web应用程序。许多站点要求用户必须通过身份验证才能使用少数几个URL（例如，主页和登录页面）。在这种情况下，最简单的是为这些特定的URL定义访问配置属性，而不是为每个受保护的资源定义访问配置属性。换句话说，有时很高兴地说默认情况下需要ROLE_SOMETHING，并且只允许该规则的某些例外，例如应用程序的登录，注销和主页。您还可以从过滤器链中完全忽略这些页面，从而绕过访问控制检查，<br>这就是我们所说的匿名身份验证。</p>
</blockquote>
<p>使用 <code>permitAll()</code> 将配置授权，以便在该特定路径上允许所有请求（来自匿名用户和已登录用户）,<code>anonymous()</code> 主要是指用户的状态（是否登录）。基本上，直到用户被“认证”为止，它就是“匿名用户”。就像每个人都有“默认角色”一样。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>基于配置来解决基于角色的访问控制是常用的方案之一。也是最容易入门的 <strong>Spring Security</strong> 访问控制技术。下一期我们将介绍基于注解的访问控制</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-javaconfig-rbac.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/12/security13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/12/security13/" class="post-title-link" itemprop="url">Spring Security13 - RBAC权限控制概念的理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-12 11:31:39" itemprop="dateCreated datePublished" datetime="2021-07-12T11:31:39+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>截止到上一篇我们已经能够简单做到用户主体认证到接口的访问控制了，但是依然满足不了实际生产的需要。 如果我们需要一个完整的权限管理系统就必须了解一下<strong>RBAC</strong>(<code>Role-Based Access Control</code>基于角色的访问控制) 的权限控制模型。</p>
<h2 id="2-为什么需要RBAC？"><a href="#2-为什么需要RBAC？" class="headerlink" title="2. 为什么需要RBAC？"></a>2. 为什么需要RBAC？</h2><p>在正式讨论<strong>RBAC</strong>模型之前，我们要思考一个问题，为什么我们要做角色权限系统？ 答案很明显，一个系统肯定具有不同访问权限的用户。比如付费用户和非付费用户的权限，如果你是 QQ音乐的会员那么你能听高音质的歌曲，如果不是就不能享受某些便利的、优质的服务。那么这是一成不变的吗？又时候为了流量增长或者拉新的需要，我们又可能把一些原来充钱才能享受的服务下放给免费用户。如果你有了会员等级那就更加复杂了，<strong>VIP1</strong>跟<strong>VIP2</strong>具有的功能肯定又有所差别了。主流的权限管理系统都是 RBAC 模型的变形和运用，只是根据不同的业务和设计方案，呈现不同的显示效果。</p>
<p>下图展示了用户和角色以及资源的简单关系：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H06218506a92a47a1afc3816b591022eep-20210712.png"></p>
<p>那为什么不直接给用户分配权限，还多此一举的增加角色这一环节呢？当然直接给用户具体的资源访问控制权限也不是不可以。只是这样做的话就少了一层关系，扩展性弱了许多。如果你的系统足够简单就不要折腾<strong>RBAC</strong>了，怎么简单就怎么玩。如果你的系统需要考虑扩展性和权限控制的多样性就必须考虑<strong>RBAC</strong>。</p>
<p>如果你有多个具有相同权限的用户，再分配权限的时候你就需要重复为用户去 Query (查询) 和 Add (赋予) 权限，如果你要修改，比如上面的 VIP1 增加一个很 Cool 的功能,你就要遍历 VIP1 用户进行修改。有了角色后，我们只需要为该角色制定好权限后，将相同权限的用户都指定为同一个角色即可，便于权限管理。</p>
<p>对于批量的用户权限调整，只需调整该用户关联的角色权限，无需遍历，既大幅提升权限调整的效率，又降低了漏调权限的概率。这样用户和资源权限解除了耦合性，这就是<strong>RBAC</strong>模型的优势所在。</p>
<h2 id="3-RBAC模型的分类"><a href="#3-RBAC模型的分类" class="headerlink" title="3. RBAC模型的分类"></a>3. RBAC模型的分类</h2><p><strong>RBAC</strong>模型可以分为：<strong>RBAC0</strong>、<strong>RBAC1</strong>、<strong>RBAC2</strong>、<strong>RBAC3</strong> 四种。其中 RBAC0 是基础，其它三种都是在 <strong>RBAC0</strong> 基础上的变种。大部分情况下，使用 <strong>RBAC0</strong> 模型就可以满足常规的权限管理系统设计了。不过一定不要拘泥于模型，要以业务需要为先导。接下来简单对四种模型进行简单的介绍一下。</p>
<h3 id="3-1-RBAC0"><a href="#3-1-RBAC0" class="headerlink" title="3.1 RBAC0"></a>3.1 RBAC0</h3><p><strong>RBAC0</strong>是基础，定义了能构成<strong>RBAC</strong>权限控制系统的最小的集合，<strong>RBAC0</strong>由四部分构成：</p>
<ul>
<li>用户（User） 权限的使用主体</li>
<li>角色（Role） 包含许可的集合</li>
<li>会话（Session）绑定用户和角色关系映射的中间通道。而且用户必须通过会话才能给用户设置角色。</li>
<li>许可（Pemission） 对特定资源的特定的访问许可。</li>
</ul>
<p><img src="https://blog-1256050353.file.myqcloud.com/H1953a3b2c57f496e9515268bff5e6382h-20210712.png"></p>
<h3 id="3-2-RBAC1"><a href="#3-2-RBAC1" class="headerlink" title="3.2 RBAC1"></a>3.2 RBAC1</h3><p><strong>RBAC1</strong>在<strong>RBAC0</strong>的基础之上引入了角色继承的概念，有了继承那么角色就有了上下级或者等级关系。父角色拥有其子角色所有的许可。通俗讲就是来说： <strong>你能干的，你的领导一定能干，反过来就不一定能行。</strong></p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H10ac31c7fb734795ae11deb08342d9c9D-20210712.png"></p>
<h3 id="3-3-RBAC2"><a href="#3-3-RBAC2" class="headerlink" title="3.3 RBAC2"></a>3.3 RBAC2</h3><blockquote>
<p>在体育比赛中，你不可能既是运动员又是裁判员！</p>
</blockquote>
<p>这是很有名的一句话。反应了我们经常出现的一种职务（其实也就是角色）冲突。有些角色产生的历史原因就是为了制约另一个角色，裁判员就是为了制约运动员从而让运动员按照规范去比赛。如果一个人兼任这两个角色，比赛必然容易出现不公正的情况从而违背竞技公平性准则。还有就是我们每个人在不同的场景都会充当不同的角色，在公司你就是特定岗位的员工，在家庭中你就是一名家庭成员。随着场景的切换，我们的角色也在随之变化。</p>
<p>所以<strong>RBAC2</strong>在<strong>RBAC0</strong>的基础上引入了静态职责分离（Static Separation of Duty，简称SSD）和动态职责分离（Dynamic Separation of Duty，简称DSD）两个约束概念。他们两个作用的生命周期是不同的;</p>
<ul>
<li><strong>SSD</strong>作用于约束用户和角色绑定时。 1.互斥角色：就像上面的例子你不能既是A又是B，互斥的角色只能二选一 ; 2. 数量约束：用户的角色数量是有限的不能多于某个基数； 3. 条件约束：只能达到某个条件才能拥有某个角色。经常用于用户等级体系，只有你充钱成为VIP才能一刀999。</li>
<li><strong>DSD</strong>作用于会话和角色交互时。当用户持有多个角色，在用户通过会话激活角色时加以条件约束，根据不同的条件执行不同的策略。</li>
</ul>
<h3 id="3-4-RBAC3"><a href="#3-4-RBAC3" class="headerlink" title="3.4 RBAC3"></a>3.4 RBAC3</h3><blockquote>
<p>我全都要!</p>
</blockquote>
<p><strong>RBAC1</strong>和<strong>RBAC2</strong>各有神通。当你拿着这两个方案给产品经理看时，他给了你一个坚定的眼神：<strong>我全都要！</strong>于是<strong>RBAC3</strong>就出现了。也就是说<strong>RBAC3 &#x3D; RBAC1 + RBAC2</strong>。</p>
<h2 id="4-RBAC-中一些概念的理解"><a href="#4-RBAC-中一些概念的理解" class="headerlink" title="4. RBAC 中一些概念的理解"></a>4. RBAC 中一些概念的理解</h2><p>四个模型说完，我们来简单对其中的一些概念进行进一步的了解。</p>
<h3 id="4-1-用户（User）"><a href="#4-1-用户（User）" class="headerlink" title="4.1 用户（User）"></a>4.1 用户（User）</h3><p>对用户的理解不应该被局限于单个用户，也可以是用户组（类似 <code>linux</code> 的 User Group）, 或许还有其它的名字比如部门或者公司；也可以是虚拟的账户，客户，甚至说第三方应用也可以算用户 。所以对用户的理解要宽泛一些，只要是有访问资源需求的主体都可以纳入用户范畴。</p>
<h3 id="4-2-角色（Role）"><a href="#4-2-角色（Role）" class="headerlink" title="4.2 角色（Role）"></a>4.2 角色（Role）</h3><p>角色是特定许可的集合以及载体。一个角色可以包含多个用户，一个用户同样的也可以属于多个角色；同样的一个角色可以包含多个用户组，一个用户组也可以具有多个角色，所以角色和用户是多对多的关系。角色是可以细分的，也就是可以继承、可以分组的。</p>
<h3 id="4-3-许可（Permission）"><a href="#4-3-许可（Permission）" class="headerlink" title="4.3 许可（Permission）"></a>4.3 许可（Permission）</h3><p>许可一般称它为权限。通常我们将访问的目标统称为资源，不管是数据还是静态资源都是资源。我们访问资源基本上又通过<strong>api</strong>接口来访问。所以一般权限都体现在对接口的控制上。再细分的话我将其划分为菜单控制，具体数据增删改查功能控制（前台体现为按钮）。另外许可具有原子性，不可再分。我们将许可授予角色时就是粒度最小的单元。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>基于角色的访问控制（RBAC）已成为高级访问控制的主要方法之一。通过RBAC，您可以控制最终用户在广义和精细级别上可以做什么。您可以指定用户是管理员，专家用户还是最终用户，并使角色和访问权限与组织中员工的职位保持一致。仅根据需要为员工完成工作的足够访问权限来分配权限。通过上面的介绍相信一定会让你有所收获。其实不管你使用什么安全框架， <strong>RBAC</strong> 都是必须掌握的</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-rbac.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/08/security12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/08/security12/" class="post-title-link" itemprop="url">Spring Security12 - 使用 JWT 认证访问接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-08 15:52:23" itemprop="dateCreated datePublished" datetime="2021-07-08T15:52:23+08:00">2021-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>之前我讲解了如何编写一个自己的 <strong>Jwt</strong> 生成器以及如何在用户认证通过后返回 <strong>Json Web Token</strong> 。今天我们来看看如何在请求中使用 <strong>Jwt</strong> 访问鉴权。<strong>DEMO</strong> 获取方法在文末。</p>
<h2 id="2-常用的Http认证方式"><a href="#2-常用的Http认证方式" class="headerlink" title="2. 常用的Http认证方式"></a>2. 常用的Http认证方式</h2><p>我们要在 <strong>Http</strong> 请求中使用 <strong>Jwt</strong> 我们就必须了解 常见的 <strong>Http</strong> 认证方式。</p>
<h3 id="2-1-HTTP-Basic-Authentication"><a href="#2-1-HTTP-Basic-Authentication" class="headerlink" title="2.1 HTTP Basic Authentication"></a>2.1 HTTP Basic Authentication</h3><p><strong>HTTP Basic Authentication</strong> 又叫基础认证，它简单地使用 <code>Base64</code> 算法对用户名、密码进行加密，并将加密后的信息放在请求头 <strong>Header</strong> 中，本质上还是明文传输用户名、密码，并不安全，所以最好在 <strong>Https</strong> 环境下使用。其认证流程如下：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/Hf4223f19ab2448e88f992c38c496c1f0O-20210708.png"></p>
<p>客户端发起 <strong>GET</strong> 请求 服务端响应返回 <strong>401 Unauthorized</strong>， <code>www-Authenticate</code> 指定认证算法，<code>realm</code> 指定安全域。然后客户端一般会弹窗提示输入用户名称和密码，输入用户名密码后放入 <strong>Header</strong> 再次请求，服务端认证成功后以 <strong>200</strong> 状态码响应客户端。</p>
<h3 id="2-2-HTTP-Digest-Authentication"><a href="#2-2-HTTP-Digest-Authentication" class="headerlink" title="2.2 HTTP Digest Authentication"></a>2.2 HTTP Digest Authentication</h3><p>为弥补 BASIC 认证存在的弱点就有了 <strong>HTTP Digest Authentication</strong> 。它又叫摘要认证。它使用随机数加上 <strong>MD5</strong> 算法来对用户名、密码进行摘要编码，流程类似 <strong>Http Basic Authentication</strong> ，但是更加复杂一些:</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H2c816ba6d88e482e958bc982fd04d46dX-20210708.png"></p>
<p>步骤1：跟基础认证一样，只不过返回带 <code>WWW-Authenticate</code> 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，<code>nonce</code>）。 首部字段 <code>WWW-Authenticate</code> 内必须包含 <code>realm</code> 和 <code>nonce</code> 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。<code>nonce</code> 是一种每次随返回的 <strong>401</strong> 响应生成的任意随机字符串。该字符串通常推荐由 <strong>Base64</strong> 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p>
<p>步骤2：接收到 <strong>401</strong> 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 <code>Authorization</code> 信息。首部字段 <code>Authorization</code> 内必须包含 <code>username、realm、nonce、uri</code> 和 <code>response</code> 的字段信息，其中，<code>realm</code> 和 <code>nonce</code> 就是之前从服务器接收到的响应中的字段。</p>
<p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 <strong>Request-URI</strong> 资源的响应。</p>
<p>并且这时会在首部字段 <strong>Authorization-Info</strong> 写入一些认证成功的相关信息。</p>
<h3 id="2-3-SSL-客户端认证"><a href="#2-3-SSL-客户端认证" class="headerlink" title="2.3 SSL 客户端认证"></a>2.3 SSL 客户端认证</h3><p><strong>SSL</strong> 客户端认证就是通常我们说的 <strong>HTTPS</strong> 。安全级别较高，但需要承担 <strong>CA</strong> 证书费用。<strong>SSL</strong> 认证过程中涉及到一些重要的概念，数字证书机构的公钥、证书的私钥和公钥、非对称算法（配合证书的私钥和公钥使用）、对称密钥、对称算法（配合对称密钥使用）。相对复杂一些这里不过多讲述。</p>
<h3 id="2-4-Form-表单认证"><a href="#2-4-Form-表单认证" class="headerlink" title="2.4 Form 表单认证"></a>2.4 Form 表单认证</h3><p>Form 表单的认证方式并不是HTTP规范。所以实现方式也呈现多样化，其实我们平常的扫码登录，手机验证码登录都属于表单登录的范畴。表单认证一般都会配合 <strong>Cookie</strong>，<strong>Session</strong> 的使用，现在很多 <strong>Web</strong> 站点都使用此认证方式。用户在登录页中填写用户名和密码，服务端认证通过后会将 <code>sessionId</code> 返回给浏览器端，浏览器会保存 <code>sessionId</code> 到浏览器的 <strong>Cookie</strong> 中。因为 HTTP 是无状态的，所以浏览器使用 <strong>Cookie</strong> 来保存 <strong>sessionId</strong>。下次客户端会在发送的请求中会携带 <code>sessionId</code> 值，服务端发现 <code>sessionId</code> 存在并以此为索引获取用户存在服务端的认证信息进行认证操作。认证过则会提供资源访问。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://www.wangweiye.cc/blog/2021/07/08/security10/">Spring Security10 - 登录后返回 JWT Token</a> 一文其实也是通过 <strong>Form</strong> 提交来获取 <strong>Jwt</strong> 其实 <strong>Jwt</strong> 跟 <strong>sessionId</strong> 同样的作用，只不过 <strong>Jwt</strong> 天然携带了用户的一些信息，而 <code>sessionId</code> 需要去进一步获取用户信息。</p>
<h3 id="2-5-Json-Web-Token-的认证方式-Bearer-Authentication"><a href="#2-5-Json-Web-Token-的认证方式-Bearer-Authentication" class="headerlink" title="2.5 Json Web Token 的认证方式 Bearer Authentication"></a>2.5 Json Web Token 的认证方式 Bearer Authentication</h3><p>我们通过表单认证获取 <strong>Json Web Token</strong> ，那么如何使用它呢? 通常我们会把 <strong>Jwt</strong> 作为令牌使用 <strong>Bearer Authentication</strong> 方式使用。<strong>Bearer Authentication</strong> 是一种基于令牌的 <strong>HTTP</strong> 身份验证方案，用户向服务器请求访问受限资源时，会携带一个 Token 作为凭证，检验通过则可以访问特定的资源。最初是在 <strong>RFC 6750</strong> 中作为 <strong>OAuth 2.0</strong> 的一部分，但有时也可以单独使用。<br>我们在使用 <strong>Bear Token</strong> 的方法是在请求头的 <code>Authorization</code> 字段中放入 <code>Bearer &lt;token&gt;</code> 的格式的加密串(<strong>Json Web Token</strong>)。<strong>请注意 Bearer 前缀与 Token 之间有一个空字符位，与基本身份验证类似，Bearer Authentication 只能在HTTPS（SSL）上使用。</strong></p>
<h2 id="3-Spring-Security-中实现接口-Jwt-认证"><a href="#3-Spring-Security-中实现接口-Jwt-认证" class="headerlink" title="3. Spring Security 中实现接口 Jwt 认证"></a>3. Spring Security 中实现接口 Jwt 认证</h2><p>接下来我们是我们该系列的重头戏 ———— 接口的 <strong>Jwt</strong> 认证。</p>
<h3 id="3-1-定义-Json-Web-Token-过滤器"><a href="#3-1-定义-Json-Web-Token-过滤器" class="headerlink" title="3.1 定义 Json Web Token 过滤器"></a>3.1 定义 Json Web Token 过滤器</h3><p>无论上面提到的哪种认证方式，我们都可以使用 <strong>Spring Security</strong> 中的 <strong>Filter</strong> 来处理。 Spring Security 默认的基础配置没有提供对 <strong>Bearer Authentication</strong> 处理的过滤器， 但是提供了处理 <strong>Basic Authentication</strong> 的过滤器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.authentication.www.BasicAuthenticationFilter</span><br></pre></td></tr></table></figure>

<p><code>BasicAuthenticationFilter</code> 继承了 <code>OncePerRequestFilter</code> 。所以我们也模仿 <code>BasicAuthenticationFilter</code> 来实现自己的 <code>JwtAuthenticationFilter</code> 。 完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.felord.spring.security.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.felord.spring.security.exception.SimpleAuthenticationEntryPoint;</span><br><span class="line"><span class="keyword">import</span> cn.felord.spring.security.jwt.JwtTokenGenerator;</span><br><span class="line"><span class="keyword">import</span> cn.felord.spring.security.jwt.JwtTokenPair;</span><br><span class="line"><span class="keyword">import</span> cn.felord.spring.security.jwt.JwtTokenStorage;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONArray;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationCredentialsNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.CredentialsExpiredException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jwt 认证拦截器 用于拦截 请求 提取jwt 认证</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/7 23:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTHENTICATION_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;Bearer &quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证如果失败由该端点进行响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AuthenticationEntryPoint</span> <span class="variable">authenticationEntryPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationEntryPoint</span>();</span><br><span class="line">    <span class="keyword">private</span> JwtTokenGenerator jwtTokenGenerator;</span><br><span class="line">    <span class="keyword">private</span> JwtTokenStorage jwtTokenStorage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtAuthenticationFilter</span><span class="params">(JwtTokenGenerator jwtTokenGenerator, JwtTokenStorage jwtTokenStorage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jwtTokenGenerator = jwtTokenGenerator;</span><br><span class="line">        <span class="built_in">this</span>.jwtTokenStorage = jwtTokenStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 如果已经通过认证</span></span><br><span class="line">        <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() != <span class="literal">null</span>) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 header 解析出 jwt 并进行认证 无token 直接进入下一个过滤器  因为  SecurityContext 的缘故 如果无权限并不会放行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(HttpHeaders.AUTHORIZATION);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(header) &amp;&amp; header.startsWith(AUTHENTICATION_PREFIX)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> header.replace(AUTHENTICATION_PREFIX, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(jwtToken)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    authenticationTokenHandle(jwtToken, request);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">                    authenticationEntryPoint.commence(request, response, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 带安全头 没有带token</span></span><br><span class="line">                authenticationEntryPoint.commence(request, response, <span class="keyword">new</span> <span class="title class_">AuthenticationCredentialsNotFoundException</span>(<span class="string">&quot;token is not found&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的认证方法  匿名访问不要携带token</span></span><br><span class="line"><span class="comment">     * 有些逻辑自己补充 这里只做基本功能的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken jwt token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">authenticationTokenHandle</span><span class="params">(String jwtToken, HttpServletRequest request)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据我的实现 有效token才会被解析出来</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> jwtTokenGenerator.decodeAndVerify(jwtToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(jsonObject)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jsonObject.getStr(<span class="string">&quot;aud&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从缓存获取 token</span></span><br><span class="line">            <span class="type">JwtTokenPair</span> <span class="variable">jwtTokenPair</span> <span class="operator">=</span> jwtTokenStorage.get(username);</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(jwtTokenPair)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;token : &#123;&#125;  is  not in cache&quot;</span>, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缓存中不存在就算 失败了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CredentialsExpiredException</span>(<span class="string">&quot;token is not in cache&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> jwtTokenPair.getAccessToken();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jwtToken.equals(accessToken)) &#123;</span><br><span class="line">                  <span class="comment">// 解析 权限集合  这里</span></span><br><span class="line">                <span class="type">JSONArray</span> <span class="variable">jsonArray</span> <span class="operator">=</span> jsonObject.getJSONArray(<span class="string">&quot;roles&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">roles</span> <span class="operator">=</span> jsonArray.toString();</span><br><span class="line"></span><br><span class="line">                List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList(roles);</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, <span class="string">&quot;[PROTECTED]&quot;</span>, authorities);</span><br><span class="line">                <span class="comment">// 构建用户认证token</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">usernamePasswordAuthenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, authorities);</span><br><span class="line">                usernamePasswordAuthenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                <span class="comment">// 放入安全上下文中</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// token 不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled())&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;token : &#123;&#125;  is  not in matched&quot;</span>, jwtToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;token is not matched&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;token : &#123;&#125;  is  invalid&quot;</span>, jwtToken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;token is invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看代码注释部分，逻辑有些地方根据你业务进行调整。<strong>匿名访问必然是不能带 Token 的！</strong></p>
<h3 id="3-2-配置-JwtAuthenticationFilter"><a href="#3-2-配置-JwtAuthenticationFilter" class="headerlink" title="3.2 配置 JwtAuthenticationFilter"></a>3.2 配置 JwtAuthenticationFilter</h3><p>首先将过滤器 <code>JwtAuthenticationFilter</code> 注入 <strong>Spring IoC</strong> 容器 ，然后一定要将 <code>JwtAuthenticationFilter</code> 顺序置于 <code>UsernamePasswordAuthenticationFilter</code> 之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// session 生成策略用无状态策略</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling().accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">SimpleAccessDeniedHandler</span>()).authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">SimpleAuthenticationEntryPoint</span>())</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilterBefore(preLoginFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                <span class="comment">// jwt 必须配置于 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                <span class="comment">// 登录  成功后返回jwt token  失败后返回 错误信息</span></span><br><span class="line">                .formLogin().loginProcessingUrl(LOGIN_PROCESSING_URL).successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler)</span><br><span class="line">                .and().logout().addLogoutHandler(<span class="keyword">new</span> <span class="title class_">CustomLogoutHandler</span>()).logoutSuccessHandler(<span class="keyword">new</span> <span class="title class_">CustomLogoutSuccessHandler</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-使用-Jwt-进行请求验证"><a href="#4-使用-Jwt-进行请求验证" class="headerlink" title="4. 使用 Jwt 进行请求验证"></a>4. 使用 Jwt 进行请求验证</h2><p>编写一个受限接口 ，我们这里是 <code>http://localhost:8080/foo/test</code> 。直接请求会被 <strong>401</strong> 。 我们通过下图方式获取 <strong>Token</strong> :</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H09c06a663cd6454faf83c335c4edb7f75-20210708.png"></p>
<p>然后在<strong>Postman</strong>中使用<strong>JWT</strong>:</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H3382afc913674799b2fe477241fbe9dbt.png"></p>
<p>最终会认证成功并访问到资源。</p>
<h2 id="5-刷新-Jwt-Token"><a href="#5-刷新-Jwt-Token" class="headerlink" title="5. 刷新 Jwt Token"></a>5. 刷新 Jwt Token</h2><p>我们已经实现了 <strong>Json Web Token</strong> 都是成对出现的逻辑。<code>accessToken</code> 用来接口请求， <code>refreshToken</code> 用来刷新 <code>accessToken</code> 。我们可以同样定义一个 <strong>Filter</strong> 可参照 上面的 <code>JwtAuthenticationFilter</code> 。只不过 这次请求携带的是 <code>refreshToken</code>，我们在过滤器中拦截 <code>URI</code>跟我们定义的刷新端点进行匹配。同样验证 <code>Token </code>，通过后像登录成功一样返回 <code>Token对</code> 即可。这里不再进行代码演示。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这是系列原创文章，总有不仔细看的同学抓不着头脑颇有微词。饭需要一口一口的吃，没有现成的可以吃，都是这么过来的，急什么。原创不易，关注才是动力。每一篇都有不同的知识点，而且它们都是相互有联系的。有不懂得地方多回头看。</p>
<p>代码在<code>day08</code>分支</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-jwt-authentication.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://wangweiye01.github.io/blog/2021/07/08/security11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="老枪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding & Life">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Coding & Life">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/2021/07/08/security11/" class="post-title-link" itemprop="url">Spring Security11 - 自定义异常处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-08 15:17:54" itemprop="dateCreated datePublished" datetime="2021-07-08T15:17:54+08:00">2021-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-06-16 15:54:53" itemprop="dateModified" datetime="2025-06-16T15:54:53+08:00">2025-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Spring-Security/" itemprop="url" rel="index"><span itemprop="name">Spring Security</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>今天分享<strong>Spring Security</strong>中需要对认证授权异常的处理</p>
<h2 id="2-Spring-Security-中的异常"><a href="#2-Spring-Security-中的异常" class="headerlink" title="2. Spring Security 中的异常"></a>2. Spring Security 中的异常</h2><p><strong>Spring Security</strong> 中的异常主要分为两大类：一类是认证异常，另一类是授权相关的异常。</p>
<h3 id="2-1-AuthenticationException"><a href="#2-1-AuthenticationException" class="headerlink" title="2.1 AuthenticationException"></a>2.1 AuthenticationException</h3><p><code>AuthenticationException</code> 是在用户认证的时候出现错误时抛出的异常。主要的子类如图：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/H79e0cdd3a3624d4ab023613aa376c63bZ-202010708.png"></p>
<p>根据该图的信息，系统用户不存在，被锁定，凭证失效，密码错误等认证过程中出现的异常都由 <code>AuthenticationException</code> 处理。</p>
<h3 id="2-2-AccessDeniedException"><a href="#2-2-AccessDeniedException" class="headerlink" title="2.2 AccessDeniedException"></a>2.2 AccessDeniedException</h3><p><code>AccessDeniedException</code> 主要是在用户在访问受保护资源时被拒绝而抛出的异常。同<code>AuthenticationException</code> 一样它也提供了一些具体的子类。如下图：</p>
<p><img src="https://blog-1256050353.file.myqcloud.com/access-deny-20210708.png"></p>
<p><code>AccessDeniedException</code> 的子类比较少，主要是 <code>CSRF</code> 相关的异常和授权服务异常。</p>
<h2 id="3-Http-状态对认证授权的规定"><a href="#3-Http-状态对认证授权的规定" class="headerlink" title="3. Http 状态对认证授权的规定"></a>3. Http 状态对认证授权的规定</h2><p><strong>Http</strong> 协议对认证授权的响应结果也有规定。</p>
<h3 id="3-1-401未授权状态"><a href="#3-1-401未授权状态" class="headerlink" title="3.1 401未授权状态"></a>3.1 401未授权状态</h3><p><strong>HTTP 401 错误 - 未授权(Unauthorized)</strong> 一般来说该错误消息表明您首先需要登录（输入有效的用户名和密码）。 如果你刚刚输入这些信息，立刻就看到一个 <code>401</code> 错误，就意味着，无论出于何种原因您的用户名和密码其中之一或两者都无效（输入有误，用户名暂时停用，账户被锁定，凭证失效等） 。总之就是认证失败了。其实正好对应我们上面的 <code>AuthenticationException</code> 。</p>
<h3 id="3-2-403-被拒绝状态"><a href="#3-2-403-被拒绝状态" class="headerlink" title="3.2 403 被拒绝状态"></a>3.2 403 被拒绝状态</h3><p><strong>HTTP 403 错误 - 被禁止(Forbidden)</strong> 出现该错误表明您在访问受限资源时没有得到许可。服务器理解了本次请求但是拒绝执行该任务，该请求不该重发给服务器。并且服务器想让客户端知道为什么没有权限访问特定的资源，服务器应该在返回的信息中描述拒绝的理由。一般实践中我们会比较模糊的表明原因。 该错误对应了我们上面的 <code>AccessDeniedException</code> 。</p>
<h2 id="4-Spring-Security-中的异常处理"><a href="#4-Spring-Security-中的异常处理" class="headerlink" title="4. Spring Security 中的异常处理"></a>4. Spring Security 中的异常处理</h2><p>我们在 <a target="_blank" rel="noopener" href="https://www.wangweiye.cc/blog/2021/07/03/security5/">Spring Security5 - 自定义配置类入口WebSecurityConfigurerAdapter</a> 一文中提到 <code>HttpSecurity</code> 提供的 <code>exceptionHandling()</code> 方法用来提供异常处理。该方法构造出 <code>ExceptionHandlingConfigurer</code> 异常处理配置类。该配置类提供了两个实用接口：</p>
<ul>
<li><strong>AuthenticationEntryPoint</strong> 该类用来统一处理 <code>AuthenticationException</code> 异常</li>
<li><strong>AccessDeniedHandler</strong> 该类用来统一处理 <code>AccessDeniedException</code> 异常</li>
</ul>
<p>我们只要实现并配置这两个异常处理类即可实现对 <strong>Spring Security</strong> 认证授权相关的异常进行统一的自定义处理。</p>
<h3 id="4-1-实现-AuthenticationEntryPoint"><a href="#4-1-实现-AuthenticationEntryPoint" class="headerlink" title="4.1 实现 AuthenticationEntryPoint"></a>4.1 实现 AuthenticationEntryPoint</h3><p>以 <code>json</code> 信息响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6 22:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo your business</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;uri&quot;</span>, request.getRequestURI());</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">resBody</span> <span class="operator">=</span> objectMapper.writeValueAsString(map);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-实现-AccessDeniedHandler"><a href="#4-2-实现-AccessDeniedHandler" class="headerlink" title="4.2 实现 AccessDeniedHandler"></a>4.2 实现 AccessDeniedHandler</h3><p>同样以 <code>json</code> 信息响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.AccessDeniedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.AccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019/11/6 22:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//todo your business</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;uri&quot;</span>, request.getRequestURI());</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">resBody</span> <span class="operator">=</span> objectMapper.writeValueAsString(map);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        printWriter.print(resBody);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-个人实践建议"><a href="#4-3-个人实践建议" class="headerlink" title="4.3 个人实践建议"></a>4.3 个人实践建议</h3><p>其实我个人建议 <strong>Http</strong> 状态码 都返回 <code>200</code> 而将 401 状态在 元信息 <code>Map</code> 中返回。因为异常状态码在浏览器端会以 <strong>error</strong> 显示。我们只要能捕捉到 <code>401</code> 和 <code>403</code>就能认定是认证问题还是授权问题。</p>
<h3 id="4-4-配置"><a href="#4-4-配置" class="headerlink" title="4.4 配置"></a>4.4 配置</h3><p>实现了上述两个接口后，我们只需要在 <code>WebSecurityConfigurerAdapter</code> 的 <code>configure(HttpSecurity http)</code> 方法中配置即可。相关的配置片段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">       .accessDeniedHandler(<span class="keyword">new</span> <span class="title class_">SimpleAccessDeniedHandler</span>())</span><br><span class="line">       .authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">SimpleAuthenticationEntryPoint</span>())</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>今天我们对 <strong>Spring Security</strong> 中的异常处理进行了讲解。分别实现了自定义的认证异常处理和自定义的授权异常处理。相关的<strong>DEMO</strong>代码在<code>day07</code>分支</p>
<p>转载自<a target="_blank" rel="noopener" href="https://www.felord.cn/spring-security-exception.html">@felord.cn</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/blog/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/blog/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">老枪</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
